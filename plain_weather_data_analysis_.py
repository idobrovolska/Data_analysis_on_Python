# -*- coding: utf-8 -*-
"""Plain_weather_data_analysis"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mYudj0lh0hniMubXiGiPGpKk1_6k0l8Q
"""

# Commented out IPython magic to ensure Python compatibility.
# %reset -f

"""## Використання бібліотек `numpy`, `matplotlib` для аналізу даних про клімат та опади

Уявімо, що ми аналізуємо дані про кліміт.

**Створення даних про температуру**

- Згенеруємо дані про щоденну температуру в ${}^{\circ} C$ протягом року, використовуючи наступну функцію:
$$
T(h) =4 \cos{\left(\frac{\pi h}{12} \right)} - 15 \cos{\left(\pi \left(\frac{h}{4380} + \frac{21}{365}\right) \right)} + 10
$$
де $h$ - година в році (може набувати значень від 0 на початку року до $24\cdot 365 - 1 = 8759$ наприкінці року).

- Візуалізуємо ці дані як графік залежності температури $T$ від номера дня в році, тобто - поклавши $h = 24 \cdot d$ і відклавши $d$ як незалежну змінну на горизонтальній осі графіка. Для задання $d$ створимо NumPy масив із 8760 елементів, в якому мінімальне значення 0, а максимальне $365-\frac{1}{24}$. Обчислені для значень із цього масива темпетарури збережемо у NumPy масиві в змінній `tempr`
"""

import numpy as np
import matplotlib.pyplot as plt

total_hours = 24 * 365
total_days = 365
d = np.linspace(0, total_days - 1/24, total_hours)
h = 24 * d
tempr = 4 * np.cos(np.pi * h / 12) - 15 * np.cos(np.pi * (h / 4380 + 21 / 365)) + 10

plt.figure(figsize=(10, 6))
plt.plot(d, tempr, label="Температура")
plt.title('Температура протягом року (щоденно)')
plt.xlabel('День')
plt.ylabel('Температура (°C)')
plt.show()

"""Виконаймо **найпростіший статистичний аналіз** раніше обчисленого масиву, збереженого у змінній `tempr`:
   - Знайдемо середнє значення температури, медіану, стандартне відхилення.
   - Визначимо номери елементів масиву, які відповідають найгарячішій та найхолоднішій температурі. Розрахуємо номери днів року, які відповідають цим індексам.

"""

mean_temp = np.mean(tempr)
median_temp = np.median(tempr)
std_temp = np.std(tempr)
percentile_25 = np.percentile(tempr, 25)
percentile_75 = np.percentile(tempr, 75)
print(f"Середня температура: {mean_temp:.1f} °C")
print(f"Медіана температури: {median_temp:.1f} °C")
print(f"Стандартне відхилення: {std_temp:.1f} °C")
print(f"25-та персентиль: {percentile_25:.1f} °C")
print(f"75-та персентиль: {percentile_75:.1f} °C")

"""Аналіз **даних про опади**:
   - Створимо масив `humid` зі значеннями щоденної кількості міліметрів опадів $R$, вважаючи її заданою виразом

     $$
   R(d) = 5 \frac{\sin^2\left(\frac{d}{11}\right)}{20 \sin^2\left(\frac{d}{97}\right) + 1}
     $$

     як функцією від номера $d$ ($d = 0, 1, ..., 364$) дня в році.

   - Обчислимо та візуалізуємо кумулятивну суму опадів за рік (як графік, на якому незалежна змінна - номер дня в році, а залежна - кількість опадів від початку року і до цього дня включно).


"""

d = np.arange(0, total_days)
humid = 5 * (np.sin(d / 11) ** 2) / (20 * (np.sin(d / 97) ** 2) + 1)
cumulative_humid = np.cumsum(humid)

plt.plot(d, cumulative_humid, label='Cumulative humid (mm)', color='red')
plt.xlabel('День')
plt.ylabel('Кумулятивна сума опадів (мм)')
plt.title('Кумулятивна сума опадів протягом року')
plt.show()

"""**Рейтинг "найбільш дощових" і "найпосушливіших" днів.**

Використаємо відповідні можливості бібліотеки NumPy для того, щоб отримати масив, в якому *номери днів року* будуть впорядковані:

  1. За зростанням кількості опадів.
  1. За спаданням кількості опадів.

Із кожного з цих масивів надрукуємо перших 20 елементів.
"""

sorted_days_ascending = np.argsort(humid)
sorted_days_descending = np.argsort(humid)[::-1]
print("Перші 20 номерів днів року за зростанням кількості опадів:",sorted_days_ascending[:20])
print("\nПерші 20 номерів днів року за спаданням кількості опадів:",sorted_days_descending[:20])

"""Використовуючи знайдені у попередньому завданні номери двадцяти днів-"рекордсменів" року із найбільшою кількістю опадів, створимо новий numpy-масив, який міститиме саму кількість опадів в ці дні.

Обчислимо **середнє геометричне** (вважатимемо для послідовності невід'ємних чисел $
 {\sqrt[{N}]{\prod _{i=1}^{N}a_{i}}} $ її середнім геометричним) для кількості опадів за ці.


"""

the_most_rainy_days = humid[sorted_days_descending[:20]]
n = len(the_most_rainy_days)
geometric_mean = np.power(np.prod(the_most_rainy_days), 1/n)
print("Середнє геометричне кількості опадів для 20 днів-рекордсменів за опадами:", geometric_mean)

"""Перетворимо масив `tempr` на двовимірний `tp2d` так, щоб замінюючи його елементи `tp2d[k, 0]` відповідали значенню температури на початку доби $k$-го дня року.

Для перевірки можна порівняти значення температури, взяті із масиву `tempr` для 0ї, 24ї, 48ї годин ($h=0, 24, 48$) та `tp2d[0, 0]`, `tp2d[1, 0]`, `tp2d[2, 0]` відповідно.
"""

tp2d = tempr.reshape(total_days, 24)
temperature_at_start_of_day = tp2d[:, 0]

h_indices = [0, 24, 48]
tempr_values = [tempr[i] for i in h_indices]
tp2d_values = [tp2d[i, 0] for i in range(3)]

print("Температура для h = 0:", tempr_values[0], "і tp2d[0, 0]:", tp2d_values[0])
print("Температура для h = 24:", tempr_values[1], "і tp2d[1, 0]:", tp2d_values[1])
print("Температура для h = 48:", tempr_values[2], "і tp2d[2, 0]:", tp2d_values[2])
print("Розмір масиву tp2d:", tp2d.shape) #Переконаємося, що двовимірний масив tp2d має розмір (365, 24).

"""Обчислимо **середнє значення температури за день**, для кожного з днів у році:"""

t_avg = np.mean(tp2d, axis=1)
print("Середня температура за день протягом року:")
for temp in t_avg:
    print(f"{temp:.3f}")

"""Обчислимо **коефіцієнт кореляції між середньою температурою та кількістю опадів**.

При цьому вважатимемо, що коефіцієнтом кореляції для послідовностей ${x_i}$ та ${y_i}$ (з однаковою кількістю $n$ елементів у них) називається величина

$$ r_{xy}={\frac {n\cdot \sum_{i} x_{i}y_{i}-\sum_{i} x_{i} \cdot  \sum_{j} y_{j}}{{\sqrt {n\cdot\sum_{i} (x_{i}^{2})-\left(\sum_{i} x_{i}\right)^{2}}}~\cdot{\sqrt {n\cdot\sum_{i} (y_{i}^{2})-\left(\sum_{i} y_{i}\right)^{2}}}}}
$$

де межі підсумовування обираються так, щоб до врахувати усі наявні елементи послідовності.

"""

m = len(t_avg)

sum_x = np.sum(t_avg)
sum_y = np.sum(humid)
sum_x2 = np.sum(t_avg**2)
sum_y2 = np.sum(humid**2)
sum_xy = np.dot(t_avg, humid)

covariation = n * sum_xy - sum_x * sum_y
standard_deviation = np.sqrt((n * sum_x2 - sum_x**2) * (n * sum_y2 - sum_y**2))

if standard_deviation != 0:
    pearson_correlation = covariation / standard_deviation
else:
    pearson_correlation = np.nan
print("Коефіцієнт кореляції Пірсона:", pearson_correlation)

"""Знайдемо номери всіх днів року, у які кількість опадів була вища, аніж її середнє значення за рік."""

mean_humid = np.mean(humid)
days_above_average_humid = np.where(humid > mean_humid)[0]
print("Номери днів з кількістю опадів вищою за середнє:", days_above_average_humid)

"""Для днів з кількістю опадів вищою за середню знайдемо найтепліший за середньодобовою температурою день."""

temps_above_average_humid = t_avg[days_above_average_humid]
hottest_day_index = days_above_average_humid[np.argmax(temps_above_average_humid)]
hottest_day_temp = temps_above_average_humid.max()
print(f"Номер найтеплішого дня за середньодобовою температурою з кількістю опадів вище середнього: {hottest_day_index}, температура: {hottest_day_temp:.3f} °C")